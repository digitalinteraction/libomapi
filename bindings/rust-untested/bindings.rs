/* automatically generated by rust-bindgen 0.69.4 */

pub const _VCRT_COMPILER_PREPROCESSOR: i32 = 1;
pub const _SAL_VERSION: i32 = 20;
pub const __SAL_H_VERSION: i32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: i32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: i32 = 0;
pub const _CRT_PACKING: i32 = 8;
pub const _HAS_EXCEPTIONS: i32 = 1;
pub const _STL_LANG: i32 = 0;
pub const _HAS_CXX17: i32 = 0;
pub const _HAS_CXX20: i32 = 0;
pub const _HAS_CXX23: i32 = 0;
pub const _HAS_NODISCARD: i32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: i32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: i32 = 1;
pub const _ARGMAX: i32 = 100;
pub const _CRT_INT_MAX: i32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: i32 = 1;
pub const _CRT_HAS_CXX17: i32 = 0;
pub const _CRT_HAS_C11: i32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: i32 = 1;
pub const __STDC_SECURE_LIB__: i32 = 200411;
pub const __GOT_SECURE_LIB__: i32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: i32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: i32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: i32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: i32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: i32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: i32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: i32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: i32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: i32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: i32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: i32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: i32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: i32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: i32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: i32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: i32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: i32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: i32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: i32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: i32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: i32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: i32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: i32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: i32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: i32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: i32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: i32 = 65;
pub const CHAR_BIT: i32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: i32 = 127;
pub const UCHAR_MAX: i32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: i32 = 127;
pub const MB_LEN_MAX: i32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: i32 = 32767;
pub const USHRT_MAX: i32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: i32 = 2147483647;
pub const UINT_MAX: i64 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: i32 = 2147483647;
pub const ULONG_MAX: i64 = 4294967295;
pub const EXIT_SUCCESS: i32 = 0;
pub const EXIT_FAILURE: i32 = 1;
pub const _WRITE_ABORT_MSG: i32 = 1;
pub const _CALL_REPORTFAULT: i32 = 2;
pub const _OUT_TO_DEFAULT: i32 = 0;
pub const _OUT_TO_STDERR: i32 = 1;
pub const _OUT_TO_MSGBOX: i32 = 2;
pub const _REPORT_ERRMODE: i32 = 3;
pub const RAND_MAX: i32 = 32767;
pub const _CVTBUFSIZE: i32 = 349;
pub const _MAX_PATH: i32 = 260;
pub const _MAX_DRIVE: i32 = 3;
pub const _MAX_DIR: i32 = 256;
pub const _MAX_FNAME: i32 = 256;
pub const _MAX_EXT: i32 = 256;
pub const _MAX_ENV: i32 = 32767;
pub const OM_VERSION: i32 = 108;
pub const OM_MEMORY_HEALTH_ERROR: i32 = 1;
pub const OM_MEMORY_HEALTH_WARNING: i32 = 8;
pub const OM_METADATA_SIZE: i32 = 448;
pub const OM_ACCEL_DEFAULT_RATE: i32 = 100;
pub const OM_ACCEL_DEFAULT_RANGE: i32 = 8;
pub const OM_MAX_PATH: i32 = 256;
pub const OM_TRUE: i32 = 1;
pub const OM_FALSE: i32 = 0;
pub const OM_OK: i32 = 0;
pub const OM_E_FAIL: i32 = -1;
pub const OM_E_UNEXPECTED: i32 = -2;
pub const OM_E_NOT_VALID_STATE: i32 = -3;
pub const OM_E_OUT_OF_MEMORY: i32 = -4;
pub const OM_E_INVALID_ARG: i32 = -5;
pub const OM_E_POINTER: i32 = -6;
pub const OM_E_NOT_IMPLEMENTED: i32 = -7;
pub const OM_E_ABORT: i32 = -8;
pub const OM_E_ACCESS_DENIED: i32 = -9;
pub const OM_E_INVALID_DEVICE: i32 = -10;
pub const OM_E_UNEXPECTED_RESPONSE: i32 = -11;
pub const OM_E_LOCKED: i32 = -12;
pub const OM_DATETIME_ZERO: i32 = 0;
pub const OM_DATETIME_BUFFER_SIZE: i32 = 20;
pub const OM_MAX_SAMPLES: i32 = 120;
pub const OM_MAX_HEADER_SIZE: i32 = 1024;
pub const OM_MAX_DATA_SIZE: i32 = 512;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    #[doc = " Initializes the Open Movement API.\n Allocates required resources for the API, initializes its state, and initiates device discovery.\n @note OmStartup() Must be called before most other functions in the API.\n       Exceptions are: OmSetLogStream(), OmSetLogCallback(), OmErrorString(), OmSetDeviceCallback(), OmSetDownloadCallback(), and all \\a OmReaderXXX() functions.\n @note If the \\a OmDeviceCallback has already been set, it will be called for all devices identified at start-up.\n @note Once successfully initialized, the caller must call OmShutdown() when finished with the API.\n @param version The version number of the API required (use OM_VERSION).\n @return \\a OM_OK if successful, error code otherwise.\n @see OmShutdown()"]
    pub fn OmStartup(version: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shuts down the Open Movement API.\n This call frees resources used by the API.\n @note Any incomplete downloads will be cancelled (and, if specified, the \\a OmDownloadCallback function will be called).\n @note Once called, functions that require OmStartup() may not be called unless OmStartup() is successfully called again.\n @return \\a OM_OK if successful, an error code otherwise.\n @see OmStartup()"]
    pub fn OmShutdown() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the stream to use for log messages.\n @note This can be called at any time.\n @param fd The file descriptor to use. Specify -1 for none; fileno(stderr) for standard error; or fileno(fopen(\"log.txt\", \"wt\")) for a file.\n @return \\a OM_OK if successful, an error code otherwise.\n @since 1.2"]
    pub fn OmSetLogStream(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " Log callback function type.\n Called for API log messages.\n Callback functions take a user-defined reference pointer, and a log message.\n @see OmSetLogCallback\n @since 1.2"]
pub type OmLogCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " Sets the callback function that is called whenever an API log message is written.\n @param logCallback The function to call when a log message is written, or \\a NULL to remove the callback.\n @param[in] reference  A user-defined reference to pass to the callback function (or \\a NULL if unwanted).\n @return \\a OM_OK if successful, an error code otherwise.\n @since 1.2"]
    pub fn OmSetLogCallback(
        logCallback: OmLogCallback,
        reference: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Device is being removed, or is already removed"]
pub const OM_DEVICE_STATUS_OM_DEVICE_REMOVED: OM_DEVICE_STATUS = 0;
#[doc = "< Device has been connected"]
pub const OM_DEVICE_STATUS_OM_DEVICE_CONNECTED: OM_DEVICE_STATUS = 1;
#[doc = " Device states used in the OmDeviceCallback handler.\n @see OmDeviceCallback, OmSetDeviceCallback"]
pub type OM_DEVICE_STATUS = ::std::os::raw::c_int;
#[doc = " Device change callback function type.\n Called for device addition or removal.\n Callback functions take a user-defined reference pointer, a device ID, and a state code.\n @see OmSetDeviceCallback"]
pub type OmDeviceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: OM_DEVICE_STATUS,
    ),
>;
extern "C" {
    #[doc = " Sets the callback function that is called whenever a device is added or removed.\n @param deviceCallback The function to call when a device is added or removed, or \\a NULL to remove the callback.\n @param[in] reference  A user-defined reference to pass to the callback function (or \\a NULL if unwanted).\n @return \\a OM_OK if successful, an error code otherwise.\n @see download.c for an example."]
    pub fn OmSetDeviceCallback(
        deviceCallback: OmDeviceCallback,
        reference: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtains the device IDs of all connected devices.\n Call \\code OmGetDeviceIds(NULL, 0) \\endcode to get the number of devices connected.\n @param[out] deviceIds A pointer to a buffer used to return the device IDs.  May be \\a NULL if \\a maxDevices = 0.\n @param maxDevices The maximum number of device IDs the supplied buffer can store.\n @retval >=0 the actual number of devices present, which may be more or less than \\a maxDevices passed.\n @retval <0 An error code.\n @see clear.c, deploy.c, test.c for examples of use."]
    pub fn OmGetDeviceIds(
        deviceIds: *mut ::std::os::raw::c_int,
        maxDevices: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "@}"]
pub type OM_DATETIME = ::std::os::raw::c_ulong;
extern "C" {
    #[doc = " Returns the firmware and hardware versions of the specified device.\n @param deviceId Identifier of the device.\n @param[out] firmwareVersion Pointer to a value to hold the firmware version, or \\a NULL if not required.\n @param[out] hardwareVersion Pointer to a value to hold the hardware version, or \\a NULL if not required.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetVersion(
        deviceId: ::std::os::raw::c_int,
        firmwareVersion: *mut ::std::os::raw::c_int,
        hardwareVersion: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the full USB serial string identity for the specified device.\n @param deviceId Identifier of the device.\n @param[out] serialBuffer A buffer to receive the string of the device'sUSB serial string identity (of size OM_MAX_PATH).\n @since 1.8"]
    pub fn OmGetDeviceSerial(
        deviceId: ::std::os::raw::c_int,
        serialBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the path to specified device's communication port.\n @param deviceId Identifier of the device.\n @param[out] portBuffer A buffer to receive the path to the device's communication port (of size OM_MAX_PATH).\n @see OmGetDevicePath()\n @since 1.7"]
    pub fn OmGetDevicePort(
        deviceId: ::std::os::raw::c_int,
        portBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the path to specified device's filesystem.\n @param deviceId Identifier of the device.\n @param[out] pathBuffer A buffer to receive the path to the device's filesystem (of size OM_MAX_PATH).\n @see OmGetDataFilename()\n @since 1.7"]
    pub fn OmGetDevicePath(
        deviceId: ::std::os::raw::c_int,
        pathBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the specified device for the current battery charging level.\n @param deviceId Identifier of the device.\n @return A non-negative value indicates the battery percentage level (0-99% = charging, 100% = fully charged).\n         A negative value indicates an error code for an issue within the API."]
    pub fn OmGetBatteryLevel(deviceId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Performs a firmware-specific self-test on the specified device (e.g. test peripherals).\n @remark A positive, non-zero self-test diagnostic code should be treated as an opaque, firmware-specific value indicating failure.\n @param deviceId Identifier of the device.\n @return \\a OM_OK if a the device successfully completed its self-test.\n         A positive value indicates the device failed its self-test with the returned diagnostic code.\n         A negative value indicates an error code for an issue within the API."]
    pub fn OmSelfTest(deviceId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the health of the NAND flash memory on the specified device.\n The device incorporates a wear-levelling 'Flash Translation Layer', error-correcting codes (ECC), and\n   data checksums to minimize any data loss.\n To do this, the device must maintain a set of spare memory blocks on each memory 'plane'.\n This call retrieves the number of spare blocks on the NAND memory on the plane with the least spare blocks.\n @param deviceId Identifier of the device.\n @return A non-negative value indicates the health of the NAND memory (a larger number is better, 0 indicates the device is unusable).\n         A negative value indicates an error code for an issue within the API."]
    pub fn OmGetMemoryHealth(deviceId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the health of the battery on the specified device.\n The device maintains an internal count of significant recharge cycles.\n @remark The device is rated to preserve 90% of its capacity (sufficient for 14-day data collection) after 500 recharge cycles.\n @param deviceId Identifier of the device.\n @return A non-negative value indicates the number of significant recharge cycles of the battery (a smaller number is better).\n         A negative value indicates an error code for an issue within the API."]
    pub fn OmGetBatteryHealth(deviceId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the specified device's current accelerometer values.\n A sample consists of three consecutive signed 16-bit numbers (representing the X-, Y- and Z-axes), with units of 1/256 g.\n @param deviceId Identifier of the device.\n @param[out] x Pointer to receive the x-axis value.\n @param[out] y Pointer to receive the y-axis value.\n @param[out] z Pointer to receive the z-axis value.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetAccelerometer(
        deviceId: ::std::os::raw::c_int,
        x: *mut ::std::os::raw::c_int,
        y: *mut ::std::os::raw::c_int,
        z: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the specified device's internal real time clock.\n @param deviceId Identifier of the device.\n @param[out] time Pointer to a value to receive the current date/time.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetTime(
        deviceId: ::std::os::raw::c_int,
        time: *mut OM_DATETIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the specified device's internal real time clock.\n @param deviceId Identifier of the device.\n @param time the date/time to set.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmSetTime(deviceId: ::std::os::raw::c_int, time: OM_DATETIME) -> ::std::os::raw::c_int;
}
#[doc = "< Automatic device-controlled LED to indicate state (default)."]
pub const OM_LED_STATE_OM_LED_AUTO: OM_LED_STATE = -1;
#[doc = "< rgb(0,0,0) Off"]
pub const OM_LED_STATE_OM_LED_OFF: OM_LED_STATE = 0;
#[doc = "< rgb(0,0,1) Blue"]
pub const OM_LED_STATE_OM_LED_BLUE: OM_LED_STATE = 1;
#[doc = "< rgb(0,1,0) Green"]
pub const OM_LED_STATE_OM_LED_GREEN: OM_LED_STATE = 2;
#[doc = "< rgb(0,1,1) Cyan"]
pub const OM_LED_STATE_OM_LED_CYAN: OM_LED_STATE = 3;
#[doc = "< rgb(1,0,0) Red"]
pub const OM_LED_STATE_OM_LED_RED: OM_LED_STATE = 4;
#[doc = "< rgb(1,0,1) Magenta"]
pub const OM_LED_STATE_OM_LED_MAGENTA: OM_LED_STATE = 5;
#[doc = "< rgb(1,1,0) Yellow"]
pub const OM_LED_STATE_OM_LED_YELLOW: OM_LED_STATE = 6;
#[doc = "< rgb(1,1,1) White"]
pub const OM_LED_STATE_OM_LED_WHITE: OM_LED_STATE = 7;
#[doc = " Enumeration of LED colours.\n @note In the \\a OM_LED_AUTO setting, when connected, the device fades from off to yellow when charging;\n       and from off to white when charged.  The device will fade to and from red instead of off when the\n       computer has recently written data to the mass storage drive (but this should not typically be observed through API access).\n @remark Values are from the bit pattern: 0b00000RGB.\n @see OmSetLed()"]
pub type OM_LED_STATE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Sets the specified device's LED colour.\n @remark The default LED status, \\a OM_LED_AUTO, allows the device to control its LED to indicate its state.\n @param deviceId Identifier of the device.\n @param ledState LED state.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmSetLed(
        deviceId: ::std::os::raw::c_int,
        ledState: OM_LED_STATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks whether the device is currently locked.\n @param deviceId Identifier of the device.\n @param[out] hasLockCode Pointer to a value that receives a flag indicating whether the device has a non-zero lock code and will be locked whenever connected (OM_FALSE or OM_TRUE).\n @return The current lock state: \\a OM_FALSE if unlocked, \\a OM_TRUE if locked, an error code otherwise.\n @since 1.2"]
    pub fn OmIsLocked(
        deviceId: ::std::os::raw::c_int,
        hasLockCode: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the lock code for the device when it is connected.\n The device will not be locked immediately, only when next connected.\n @param deviceId Identifier of the device.\n @param code Lock code to use. 0 = no lock, 0xffff is reserved for internal use.\n @return The 'initial lock' state: \\a OM_FALSE if unlocked, \\a OM_TRUE if locked.  Or an error code otherwise.\n @since 1.2"]
    pub fn OmSetLock(
        deviceId: ::std::os::raw::c_int,
        code: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the lock code for the device when it is connected.\n The device will not be locked immediately, only when next connected.\n @param deviceId Identifier of the device.\n @param code Unlock code to use (0 is reserved to indicate no lock code, 0xffff is reserved for internal use).\n @return The current lock state: \\a OM_FALSE if unlocked, \\a OM_TRUE if the unlock code was not accepted, an error code otherwise.\n @since 1.2"]
    pub fn OmUnlock(
        deviceId: ::std::os::raw::c_int,
        code: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the error-correcting code flag for the specified device.\n @param deviceId Identifier of the device.\n @param state \\a OM_TRUE to enable ECC, \\a OM_FALSE to disable ECC.\n @return \\a OM_OK if successful, an error code otherwise.\n @since 1.2"]
    pub fn OmSetEcc(
        deviceId: ::std::os::raw::c_int,
        state: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the error-correcting code flag for the specified device.\n @param deviceId Identifier of the device.\n @return \\a OM_TRUE if ECC enabled, \\a OM_FALSE if ECC disabled, an error code otherwise.\n @since 1.2"]
    pub fn OmGetEcc(deviceId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Issues a direct command over the CDC port for a particular device.\n Waits for a line with the specified response (until the timeout is hit).\n If the response is found, and parsing is required (parseParts != NULL), it parses the response (at '=' and ',' places) up to 'parseMax' token.\n @note This method is not generally recommended -- incorrect results could lead to unspecified behaviour.\n @param deviceId Identifier of the device.\n @param command The command string to send (typically followed with CRLF).\n @param[out] buffer A buffer to hold the response.\n @param bufferSize The size (in bytes) of the output buffer.\n @param expected The expected response prefix, or \\a NULL if not specified (command will timeout).\n @param timeoutMs The time, in milliseconds, after which the command will time-out and return.\n @param[out] parseParts A buffer to hold the parsed response, or \\a NULL if parsing is not required.\n @param parseMax The maximum number of entries the \\a parsePoints buffer can hold.\n @return The offset in the buffer of the start of the expected response, if found; or the offset in the buffer of the start of the error response string; otherwise the length of the unrecognized response.\n @since 1.2"]
    pub fn OmCommand(
        deviceId: ::std::os::raw::c_int,
        command: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
        expected: *const ::std::os::raw::c_char,
        timeoutMs: ::std::os::raw::c_uint,
        parseParts: *mut *mut ::std::os::raw::c_char,
        parseMax: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the specified device's delayed activation start and stop times.\n @param deviceId Identifier of the device.\n @param[out] startTime Pointer to a value to receive the start date/time.\n @param[out] stopTime Pointer to a value to receive the stop date/time.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetDelays(
        deviceId: ::std::os::raw::c_int,
        startTime: *mut OM_DATETIME,
        stopTime: *mut OM_DATETIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the specified device's delayed activation start and stop times to use for a new recording session.\n To set the device to always record:\n      \\code OmSetDelays(deviceId, OM_DATETIME_ZERO, OM_DATETIME_INFINITE); \\endcode\n To set the device to never record:\n      \\code OmSetDelays(deviceId, OM_DATETIME_INFINITE, OM_DATETIME_INFINITE); \\endcode\n @note This API call does not alter existing session data on the device, and only takes full effect when OmEraseDataAndCommit() is called.\n @remark When not connected, a device would stop recording, even within the recording time window, if either storage or battery were to be exhausted.\n         When not recording, devices keep themselves in a low power mode to conserve battery.\n @param deviceId Identifier of the device.\n @param startTime The start date and time.\n @param stopTime The stop date and time.\n @return \\a OM_OK if successful, an error code otherwise.\n @see OmEraseDataAndCommit()"]
    pub fn OmSetDelays(
        deviceId: ::std::os::raw::c_int,
        startTime: OM_DATETIME,
        stopTime: OM_DATETIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the specified device's session identifier.\n @param deviceId Identifier of the device.\n @param[out] sessionId Pointer to a value to receive the session ID.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetSessionId(
        deviceId: ::std::os::raw::c_int,
        sessionId: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the specified device's session identifier to be used at the next recording session.\n @note This API call does not alter existing session data on the device, and only takes full effect when OmEraseDataAndCommit() is called.\n @param deviceId Identifier of the device.\n @param sessionId A value to set as the session ID.\n @return \\a OM_OK if successful, an error code otherwise.\n @see OmEraseDataAndCommit()"]
    pub fn OmSetSessionId(
        deviceId: ::std::os::raw::c_int,
        sessionId: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the contents of the specified device's metadata scratch buffer.\n @remark A suggested decoding of name/value pairs that preserves characters outside the non-control-ASCII range is URL-decoding to UTF-8 strings.\n @param deviceId Identifier of the device.\n @param[out] metadata A pointer to a buffer to receive the metadata, must be at least (OM_METADATA_SIZE + 1) as the value will be null-terminated.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetMetadata(
        deviceId: ::std::os::raw::c_int,
        metadata: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the specified device's metadata scratch buffer to be used for the next recording session.\n @note This API call does not alter existing session data on the device, and only takes full effect when OmEraseDataAndCommit() is called -- after which, all existing metadata on the device will be replaced.\n @remark A suggested encoding of name/value pairs that preserves characters outside the non-control-ASCII range is URL-encoding from UTF-8 strings.\n @param deviceId Identifier of the device.\n @param[out] metadata A pointer to the metadata to store, or \\a NULL if clearing the metadata.\n @param size The size of the specified metaData.  Can be 0 to clear the metadata.  If larger than OM_METADATA_SIZE, additional bytes will be ignored.\n @see OmEraseDataAndCommit()\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmSetMetadata(
        deviceId: ::std::os::raw::c_int,
        metadata: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the date and time that the specified device was last configured.\n @param deviceId Identifier of the device.\n @param[out] time Pointer to a value to receive the last configuration date and time.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetLastConfigTime(
        deviceId: ::std::os::raw::c_int,
        time: *mut OM_DATETIME,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Data file not erased but metadata just updated (this is not recommended as it could lead to a data/metadata mismatch)."]
pub const OM_ERASE_LEVEL_OM_ERASE_NONE: OM_ERASE_LEVEL = 0;
#[doc = "< Data file is removed and a new one created with the current metadata."]
pub const OM_ERASE_LEVEL_OM_ERASE_DELETE: OM_ERASE_LEVEL = 1;
#[doc = "< Device file-system is re-created and a new data file is created with the current metadata."]
pub const OM_ERASE_LEVEL_OM_ERASE_QUICKFORMAT: OM_ERASE_LEVEL = 2;
#[doc = "< All blocks on the NAND flash memory are cleared, the file-system is cleanly re-created, and a new data file is created with the current metadata."]
pub const OM_ERASE_LEVEL_OM_ERASE_WIPE: OM_ERASE_LEVEL = 3;
#[doc = " Erase levels for OmEraseDataAndCommit() function.\n @see OmEraseDataAndCommit\n @since 1.2"]
pub type OM_ERASE_LEVEL = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Erases the specified device storage and commits the metadata and settings.\n To fully wipe a device, the caller can execute:\n \\code\n     OmSetSessionId(deviceId, 0);\n     OmSetMetadata(deviceId, NULL, 0);\n     OmSetDelays(deviceId, OM_DATETIME_INFINITE, OM_DATETIME_INFINITE);\n     OmSetAccelConfig(deviceId, OM_ACCEL_DEFAULT_RATE, OM_ACCEL_DEFAULT_RANGE);\n     OmEraseDataAndCommit(deviceId, OM_ERASE_WIPE);\n \\endcode\n And similarly, to cleanly re-configure a device, the same sequence can be called with non-zero values.\n @note To modify the file system, the device prevents the computer from accessing the data store (by temporarily disconnecting it).\n       Therefore, the operation will report failure if a download is in progress - the download must complete or first be cancelled with OmCancelDownload().\n @param deviceId Identifier of the device.\n @param eraseLevel The erase level to use, one of: OM_ERASE_NONE, OM_ERASE_DELETE, OM_ERASE_QUICKFORMAT, OM_ERASE_WIPE\n @return \\a OM_OK if successful, an error code otherwise.\n @since 1.2"]
    pub fn OmEraseDataAndCommit(
        deviceId: ::std::os::raw::c_int,
        eraseLevel: OM_ERASE_LEVEL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the specified device's accelerometer configuration.\n @param deviceId Identifier of the device.\n @param[out] rate Pointer to a value to receive the sampling rate in Hz (6 [=6.25], 12 [=12.5], 25, 50, 100, 200, 400, 800, 1600, 3200). Overloaded since 1.8 with negative ranges being \"low power\" mode.\n @param[out] range Pointer to a value to receive the sampling range in +/- G (2, 4, 8, 16). Overloaded since 1.8 with the bits 16-32 being the synchronous gyro range in degrees/sec (125, 250, 500, 1000, 2000) with compatible devices.\n @return \\a OM_OK if successful, an error code otherwise.\n @see OmSetAccelConfig()\n @since 1.3, 1.8 for overloaded low-power and synchronous gyro range."]
    pub fn OmGetAccelConfig(
        deviceId: ::std::os::raw::c_int,
        rate: *mut ::std::os::raw::c_int,
        range: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the specified device's accelerometer configuration to be used at the next recording session.\n @note This API call does not alter the existing settings, and only takes full effect when OmEraseDataAndCommit() is called.\n @param deviceId Identifier of the device.\n @param rate Sampling rate value in Hz (6 [=6.25], 12 [=12.5], 25, 50, 100, 200, 400, 800, 1600, 3200).  Overloaded since 1.8 with negative ranges being \"low power\" mode.\n @param range Sampling range value in +/- G (2, 4, 8, 16). Overloaded since 1.8 with the bits 16-32 being the synchronous gyro range in degrees/sec (125, 250, 500, 1000, 2000) with compatible devices.\n @return \\a OM_OK if successful, an error code otherwise.\n @see OmGetAccelConfig()\n @since 1.3, 1.8 for overloaded low-power and synchronous gyro range."]
    pub fn OmSetAccelConfig(
        deviceId: ::std::os::raw::c_int,
        rate: ::std::os::raw::c_int,
        range: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Queries the specified device's 'maximum sample' value.  This should always be set to 0.\n @param deviceId Identifier of the device.\n @param[out] value Pointer to a value to receive the max sample value.\n @return \\a OM_OK if successful, an error code otherwise.\n @see OmSetMaxSamples()\n @since 1.5"]
    pub fn OmGetMaxSamples(
        deviceId: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the specified device's 'maximum sample' value.  This should always be set to 0.\n @note This API call does not alter the existing settings, and only takes full effect when OmEraseDataAndCommit() is called.\n @param deviceId Identifier of the device.\n @param value Value setting (should be 0)\n @return \\a OM_OK if successful, an error code otherwise.\n @see OmGetMaxSamples()\n @since 1.5"]
    pub fn OmSetMaxSamples(
        deviceId: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< No download information"]
pub const OM_DOWNLOAD_STATUS_OM_DOWNLOAD_NONE: OM_DOWNLOAD_STATUS = 0;
#[doc = "< Data download failed with an error (the value parameter to OmDownloadCallback indicates a diagnostic error code)"]
pub const OM_DOWNLOAD_STATUS_OM_DOWNLOAD_ERROR: OM_DOWNLOAD_STATUS = 1;
#[doc = "< Data download progress (the value parameter to OmDownloadCallback indicates progress percentage)"]
pub const OM_DOWNLOAD_STATUS_OM_DOWNLOAD_PROGRESS: OM_DOWNLOAD_STATUS = 2;
#[doc = "< Data download completed successfully"]
pub const OM_DOWNLOAD_STATUS_OM_DOWNLOAD_COMPLETE: OM_DOWNLOAD_STATUS = 3;
#[doc = "< Data download was cancelled cleanly"]
pub const OM_DOWNLOAD_STATUS_OM_DOWNLOAD_CANCELLED: OM_DOWNLOAD_STATUS = 4;
#[doc = " Download states used in the OmDownloadCallback handler.\n @see OmDownloadCallback, OmSetDownloadCallback"]
pub type OM_DOWNLOAD_STATUS = ::std::os::raw::c_int;
#[doc = " Download update callback function type.\n Called for download progress, completion, cancellation, or failure.\n Callback functions take a user-defined reference pointer, a device ID, a status code, and a value.\n @see OmSetDownloadCallback"]
pub type OmDownloadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: OM_DOWNLOAD_STATUS,
        arg4: ::std::os::raw::c_int,
    ),
>;
#[doc = " Download chunk callback function type.\n Called for download chunks.\n Callback functions take a user-defined reference pointer, a device ID, a buffer pointer, a file position and a buffer size.\n @see OmSetDownloadCallback\n @since 1.4"]
pub type OmDownloadChunkCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    #[doc = " Sets the callback function that is called for download progress, completion, cancellation, or failure.\n @param downloadCallback The function to call on download activity, or \\a NULL to remove the callback.\n @param[in] reference  A user-defined reference to pass to the callback function (or \\a NULL if unwanted).\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmSetDownloadCallback(
        downloadCallback: OmDownloadCallback,
        reference: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the chunk callback function that is called when a new download chunk is received.\n @param downloadChunkCallback The function to call on download activity, or \\a NULL to remove the callback.\n @param[in] reference  A user-defined reference to pass to the callback function (or \\a NULL if unwanted).\n @return \\a OM_OK if successful, an error code otherwise.\n @since 1.4"]
    pub fn OmSetDownloadChunkCallback(
        downloadChunkCallback: OmDownloadChunkCallback,
        reference: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the data file size of the specified device.\n @param deviceId Identifier of the device.\n @see OmBeginDownloading()\n @since 1.4"]
    pub fn OmGetDataFileSize(deviceId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the path to the data file for the specified device.\n @param deviceId Identifier of the device.\n @param[out] filenameBuffer A buffer to receive the data filename (of size OM_MAX_PATH).\n @see OmReaderOpen()\n @since 1.2"]
    pub fn OmGetDataFilename(
        deviceId: ::std::os::raw::c_int,
        filenameBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the size, time-range, and internal chunking of the data buffer.\n @param deviceId Identifier of the device.\n @param[out] dataBlockSize A pointer to a value to receive the block size of the data (512 bytes), or \\a NULL if not required.\n @param[out] dataOffsetBlocks A pointer to a value to receive the offset of the data in blocks (same as the header size: 2 blocks), or \\a NULL if not required.\n @param[out] dataNumBlocks A pointer to a value to receive the size of the data buffer in blocks, or \\a NULL if not required.\n @param[out] startTime A pointer for the start time of the data, or \\a NULL if not required.\n @param[out] endTime A pointer for the end time of the data, or \\a NULL if not required.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmGetDataRange(
        deviceId: ::std::os::raw::c_int,
        dataBlockSize: *mut ::std::os::raw::c_int,
        dataOffsetBlocks: *mut ::std::os::raw::c_int,
        dataNumBlocks: *mut ::std::os::raw::c_int,
        startTime: *mut OM_DATETIME,
        endTime: *mut OM_DATETIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Begin downloading the data from the current device.\n Once the download has successfully started, the call returns immediately, and the download continues in another thread.\n The user-specified download callback is called to notify the user about download progress, completion, cancellation, or failure.\n @param deviceId Identifier of the device.\n @param dataOffsetBlocks Start offset of the download (in blocks), typically 0.\n @param dataLengthBlocks Length of the data to download (in blocks), -1 = all.\n @param destinationFile File to write to (will truncate any existing file).\n        If NULL, will read the file but not write to a file -- this can be used in\n        conjunction with the OmSetDownloadChunkCallback() so the application can stream the data to another location.\n @return \\a OM_OK if successfully started the download, an error code otherwise.\n @see OmSetDownloadCallback(), OmSetDownloadChunkCallback(), OmWaitForDownload(), OmCancelDownload()"]
    pub fn OmBeginDownloading(
        deviceId: ::std::os::raw::c_int,
        dataOffsetBlocks: ::std::os::raw::c_int,
        dataLengthBlocks: ::std::os::raw::c_int,
        destinationFile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Begin downloading the data from the current device, passing an additional reference.\n Once the download has successfully started, the call returns immediately, and the download continues in another thread.\n The user-specified download callback is called to notify the user about download progress, completion, cancellation, or failure.\n @param deviceId Identifier of the device.\n @param dataOffsetBlocks Start offset of the download (in blocks), typically 0.\n @param dataLengthBlocks Length of the data to download (in blocks), -1 = all.\n @param destinationFile File to write to (will truncate any existing file).\n        If NULL, will read the file but not write to a file -- this can be used in\n        conjunction with the OmSetDownloadChunkCallback() so the application can stream the data to another location.\n @param reference An additional reference to pass to the download callbacks -- if NULL, the reference given when registering the callback will be used instead.\n @return \\a OM_OK if successfully started the download, an error code otherwise.\n @see OmBeginDownloading(), OmSetDownloadCallback(), OmSetDownloadChunkCallback(), OmWaitForDownload(), OmCancelDownload()\n @since 1.4"]
    pub fn OmBeginDownloadingReference(
        deviceId: ::std::os::raw::c_int,
        dataOffsetBlocks: ::std::os::raw::c_int,
        dataLengthBlocks: ::std::os::raw::c_int,
        destinationFile: *const ::std::os::raw::c_char,
        reference: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function queries the status of the specified device's asynchronous download.\n @remark Using the user-specified download callback would be sufficient for most applications.\n @param deviceId Identifier of the device.\n @param[out] downloadStatus Current status of the download (whether none, in-progress, completed, cancelled or failed).\n @param[out] downloadValue A pointer to be used to store a value associated with the download status.\n             If the \\a downloadStatus is \\a OM_DOWNLOAD_PROGRESS, this stores the percent progress.\n             If the \\a downloadStatus is \\a OM_DOWNLOAD_ERROR, this stores a diagnostic code.\n             Can be \\a NULL if not required.\n @return \\a OM_OK if successfully obtained the download status, an error code otherwise.\n @see OmSetDownloadCallback()"]
    pub fn OmQueryDownload(
        deviceId: ::std::os::raw::c_int,
        downloadStatus: *mut OM_DOWNLOAD_STATUS,
        downloadValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This function waits for the specified device's asynchronous download to finish.\n The call returns immediately if a download is not in progress, or will blocks and return when the download completes, is cancelled, or fails.\n @remark This call is useful for single-threaded, non-interactive applications.\n @remark The user-specified download callback, if specified, is still called (and is useful for progress reports).\n @param deviceId Identifier of the device.\n @param[out] downloadStatus Final status of the download (whether completed, cancelled or failed).\n @param[out] downloadValue A pointer to be used to store a final value for the download - if the \\a downloadStatus\n             is \\a OM_DOWNLOAD_ERROR, this stores a diagnostic code.  Can be \\a NULL if not required.\n @return \\a OM_OK if successfully waited for the download, an error code otherwise.\n @see OmSetDownloadCallback(), OmBeginDownloading()"]
    pub fn OmWaitForDownload(
        deviceId: ::std::os::raw::c_int,
        downloadStatus: *mut OM_DOWNLOAD_STATUS,
        downloadValue: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cancel the current download of the data on the specified device.\n @remark If the download is still in progress, this will cancel the download (which will trigger a call to the user's download callback, if specified).\n @param deviceId Identifier of the device.\n @return \\a OM_OK if successfully cancelled the download, an error code otherwise.\n @see OmSetDownloadCallback, OmBeginDownloading()"]
    pub fn OmCancelDownload(deviceId: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns an error string for the specified API return code.\n @param status An API return value.\n @return Error string for the specified status."]
    pub fn OmErrorString(status: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @private Convert a date/time number from a string (\"YYYY-MM-DD hh:mm:ss\")"]
    pub fn OmDateTimeFromString(value: *const ::std::os::raw::c_char) -> OM_DATETIME;
}
extern "C" {
    pub fn OmDateTimeToString(
        value: OM_DATETIME,
        buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " Handle to a reader object.\n Obtained by calling OmReaderOpen(), and disposed of with OmReaderClose().\n @see OmReaderOpen(), OmReaderClose()"]
pub type OmReaderHandle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " Opens a binary data file for reading.\n Parses the file header and places the stream at the first block of data.\n @param binaryFilename The file name of the binary file to open.\n @see OmReaderNextBlock(), OmReaderClose()\n @return If successful, a handle to the reader object, otherwise \\a NULL"]
    pub fn OmReaderOpen(binaryFilename: *const ::std::os::raw::c_char) -> OmReaderHandle;
}
extern "C" {
    #[doc = " Read the size, time-range, and internal chunking of the binary file.\n @param reader The handle to the reader.\n @param[out] dataBlockSize A pointer to a value to receive the block size of the data (512 bytes), or \\a NULL if not required.\n @param[out] dataOffsetBlocks A pointer to a value to receive the offset of the data in blocks (same as the header size: 2 blocks), or \\a NULL if not required.\n @param[out] dataNumBlocks A pointer to a value to receive the size of the data buffer in blocks, or \\a NULL if not required.\n @param[out] startTime A pointer for the start time of the data, or \\a NULL if not required.\n @param[out] endTime A pointer for the end time of the data, or \\a NULL if not required.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmReaderDataRange(
        reader: OmReaderHandle,
        dataBlockSize: *mut ::std::os::raw::c_int,
        dataOffsetBlocks: *mut ::std::os::raw::c_int,
        dataNumBlocks: *mut ::std::os::raw::c_int,
        startTime: *mut OM_DATETIME,
        endTime: *mut OM_DATETIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the device id, session id and metadata of the binary file.\n @param reader The handle to the reader.\n @param[out] deviceId A pointer to a value to receive the device id, or \\a NULL if not required.\n @param[out] sessionId A pointer to a value to receive the session id, or \\a NULL if not required.\n @return A pointer to a value to receive the pointer to the metadata, or \\a NULL if the reader handle is not valid."]
    pub fn OmReaderMetadata(
        reader: OmReaderHandle,
        deviceId: *mut ::std::os::raw::c_int,
        sessionId: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the current block index of the reader.\n @param reader The handle to the reader.\n @return If non-negative, the block position within the file, an error code otherwise."]
    pub fn OmReaderDataBlockPosition(reader: OmReaderHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Seeks the file reader to the specified data block.\n @param reader The handle to the reader.\n @param dataBlockNumber If positive, the data block index from the start of the file (after any header blocks); if negative, the data block index from the end of the file.\n @return \\a OM_OK if successful, an error code otherwise."]
    pub fn OmReaderDataBlockSeek(
        reader: OmReaderHandle,
        dataBlockNumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reads the next block of data from the binary file.\n @param reader The handle to the reader.\n @retval >0 a positive number of samples in the buffer successfully read.\n @retval 0 this block is unreadable but additional blocks remain (call OmReaderNextBlock() again).\n @retval -1, the end-of-file has been reached.\n @retval Otherwise, an error code.\n @see OmReaderBuffer(), OmReaderTimestamp()"]
    pub fn OmReaderNextBlock(reader: OmReaderHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtains a pointer to the buffer of samples read, and unpacked, by OmReaderNextBlock().\n The number of samples available is specified by the return value of the previous OmReaderNextBlock() call.\n Each sample consists of three consecutive signed 16-bit numbers (representing the X-, Y- and Z-axes), with units of 1/256 g.\n @note The buffer contents are only guaranteed until the next call to OmReaderNextBlock() or OmReaderClose().\n @param reader The handle to the reader.\n @return A pointer to the buffer of samples just read.\n @see OmReaderTimestamp()"]
    pub fn OmReaderBuffer(reader: OmReaderHandle) -> *mut ::std::os::raw::c_short;
}
extern "C" {
    #[doc = " Determines the timestamp of the specified sample in the buffer read by OmReaderNextBlock().\n\n Actual readings from the real-time-clock are stored once per block (with precise offset information).\n As the true sampling rate is subject to error (it is subject to the accelerometer device's internal sampling)\n   this function must interpolate over these timestamps to produce the actual real-time value for each sample.\n\n @param reader The handle to the reader.\n @param index The sample index, must be >= 0 and < the number of samples returned from OmReaderNextBlock().\n @param[out] fractional A pointer to a value to hold the 1/65536th of a second fractional time offset, or \\a NULL if not required.\n @return The packed date/time value of the sample at the start of the buffer, or 0 if none (e.g. an invalid index)."]
    pub fn OmReaderTimestamp(
        reader: OmReaderHandle,
        index: ::std::os::raw::c_int,
        fractional: *mut ::std::os::raw::c_ushort,
    ) -> OM_DATETIME;
}
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_DEVICEID: OM_READER_VALUE_TYPE = 3;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_SESSIONID: OM_READER_VALUE_TYPE = 4;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_SEQUENCEID: OM_READER_VALUE_TYPE = 5;
#[doc = "< Raw light sensor reading."]
pub const OM_READER_VALUE_TYPE_OM_VALUE_LIGHT: OM_READER_VALUE_TYPE = 7;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_TEMPERATURE: OM_READER_VALUE_TYPE = 8;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_EVENTS: OM_READER_VALUE_TYPE = 9;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_BATTERY: OM_READER_VALUE_TYPE = 10;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_SAMPLERATE: OM_READER_VALUE_TYPE = 11;
#[doc = "< log10(lux) * 10^3   therefore   lux = pow(10.0, log10LuxTimes10Power3 / 1000.0)"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_LIGHT_LOG10LUXTIMES10POWER3: OM_READER_VALUE_TYPE = 107;
#[doc = "< Temperature sensor reading in milli-centigrade"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_TEMPERATURE_MC: OM_READER_VALUE_TYPE = 108;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_BATTERY_MV: OM_READER_VALUE_TYPE = 110;
#[doc = " \\cond"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_BATTERY_PERCENT: OM_READER_VALUE_TYPE = 210;
#[doc = "< Number of axes per sample.  Synchronous axes are [GxGyGz]AxAyAz[[MxMyMz]], 3=A, 6=GA, 9=GAM"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_AXES: OM_READER_VALUE_TYPE = 12;
#[doc = "< Scaling: number of units for 1g: CWA=256, AX6=2048 (+/-16g), 4096 (+/-8g), 8192 (+/-4g), 16384 (+/-2g)"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_SCALE_ACCEL: OM_READER_VALUE_TYPE = 13;
#[doc = "< Scaling: number of degrees per second that (2^15=)32768 represents: AX6= 2000, 1000, 500, 250, 125, 0=off."]
pub const OM_READER_VALUE_TYPE_OM_VALUE_SCALE_GYRO: OM_READER_VALUE_TYPE = 14;
#[doc = "< Scaling: number of units for 1uT: AX6=16"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_SCALE_MAG: OM_READER_VALUE_TYPE = 15;
#[doc = "< Axis index for Accel-X (-Y and -Z follow), AX3=0, AX6(A)=0, AX6(GA/GAM)=3, not-present=-1"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_ACCEL_AXIS: OM_READER_VALUE_TYPE = 16;
#[doc = "< Axis index for Gyro-X (-Y and -Z follow), AX6(GA/GAM)=0, not-present=-1"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_GYRO_AXIS: OM_READER_VALUE_TYPE = 17;
#[doc = "< Axis index for Mag-X (-Y and -Z follow), AX6(GAM)=6, not-present=-1"]
pub const OM_READER_VALUE_TYPE_OM_VALUE_MAG_AXIS: OM_READER_VALUE_TYPE = 18;
#[doc = " Reader value indexes for OmReaderGetValue() function.\n @see OmReaderGetValue\n @since 1.3"]
pub type OM_READER_VALUE_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Returns a specific value type from the buffer read by OmReaderNextBlock().\n\n @param reader The handle to the reader.\n @param valueType The value to return.\n @return The raw value requested for the current block.\n @see OM_READER_VALUE_TYPE\n @since 1.3"]
    pub fn OmReaderGetValue(
        reader: OmReaderHandle,
        valueType: OM_READER_VALUE_TYPE,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OM_READER_HEADER_PACKET {
    #[doc = "< @ 0 +2 ASCII \"MD\", little-endian (0x444D)"]
    pub packetHeader: ::std::os::raw::c_ushort,
    #[doc = "< @ 2 +2 Packet length (1020 bytes, with header (4) = 1024 bytes total)"]
    pub packetLength: ::std::os::raw::c_ushort,
    #[doc = "< @ 4 +1 (1 byte reserved)"]
    pub reserved1: ::std::os::raw::c_uchar,
    #[doc = "< @ 5 +2 Device identifier (low 16-bits)"]
    pub deviceId: ::std::os::raw::c_ushort,
    #[doc = "< @ 7 +4 Unique session identifier"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "< @11 +2 (2 bytes reserved)"]
    pub reserved2: ::std::os::raw::c_ushort,
    #[doc = "< @13 +4 Start time for delayed logging"]
    pub loggingStartTime: OM_DATETIME,
    #[doc = "< @17 +4 Stop time for delayed logging"]
    pub loggingEndTime: OM_DATETIME,
    #[doc = "< @21 +4 Preset maximum number of samples to collect, 0 = unlimited"]
    pub loggingCapacity: ::std::os::raw::c_uint,
    #[doc = "< @25 +11 (11 bytes reserved)"]
    pub reserved3: [::std::os::raw::c_uchar; 11usize],
    #[doc = "< @36 +1 Sampling rate"]
    pub samplingRate: ::std::os::raw::c_uchar,
    #[doc = "< @37 +4 Last change metadata time"]
    pub lastChangeTime: ::std::os::raw::c_uint,
    #[doc = "< @41 +1 Firmware revision number"]
    pub firmwareRevision: ::std::os::raw::c_uchar,
    #[doc = "< @42 +2 Time Zone offset from UTC (in minutes), 0xffff = -1 = unknown"]
    pub timeZone: ::std::os::raw::c_short,
    #[doc = "< @44 +20 (20 bytes reserved)"]
    pub reserved4: [::std::os::raw::c_uchar; 20usize],
    #[doc = "< @64 +448 Scratch buffer / meta-data (448 characters)"]
    pub annotation: [::std::os::raw::c_uchar; 448usize],
    #[doc = "< @512 +512 Reserved for post-collection scratch buffer / meta-data (512 characters)"]
    pub reserved: [::std::os::raw::c_uchar; 512usize],
}
#[test]
fn bindgen_test_layout_OM_READER_HEADER_PACKET() {
    const UNINIT: ::std::mem::MaybeUninit<OM_READER_HEADER_PACKET> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OM_READER_HEADER_PACKET>(),
        1024usize,
        concat!("Size of: ", stringify!(OM_READER_HEADER_PACKET))
    );
    assert_eq!(
        ::std::mem::align_of::<OM_READER_HEADER_PACKET>(),
        1usize,
        concat!("Alignment of ", stringify!(OM_READER_HEADER_PACKET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetHeader) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(packetHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(packetLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceId) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionId) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(sessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loggingStartTime) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(loggingStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loggingEndTime) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(loggingEndTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loggingCapacity) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(loggingCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samplingRate) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(samplingRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastChangeTime) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(lastChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareRevision) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(firmwareRevision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeZone) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(timeZone)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(annotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_HEADER_PACKET),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[doc = " Accesses the contents of a raw header packet.\n The packet will have already been loaded by the call to OmReaderOpen(), and will remain valid until OmReaderClose() is called for the same reader handle.\n This would not typically be used by an API client.\n @param reader The handle to the reader.\n @return A pointer to the bytes in the raw header packet."]
    pub fn OmReaderRawHeaderPacket(reader: OmReaderHandle) -> *mut OM_READER_HEADER_PACKET;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OM_READER_DATA_PACKET {
    #[doc = "< @ 0 +2  ASCII \"AX\", little-endian (0x5841)"]
    pub packetHeader: ::std::os::raw::c_ushort,
    #[doc = "< @ 2 +2  Packet length (508 bytes, with header (4) = 512 bytes total)"]
    pub packetLength: ::std::os::raw::c_ushort,
    #[doc = "< @ 4 +2  Top bit set: 15-bit fraction of a second for the time stamp, the timestampOffset was already adjusted to minimize this assuming ideal sample rate; Top bit clear: 15-bit device identifier, 0 = unknown;"]
    pub deviceFractional: ::std::os::raw::c_ushort,
    #[doc = "< @ 6 +4  Unique session identifier, 0 = unknown"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "< @10 +4  Sequence counter, each packet has a new number (reset if restarted)"]
    pub sequenceId: ::std::os::raw::c_uint,
    #[doc = "< @14 +4  Last reported RTC value, 0 = unknown"]
    pub timestamp: OM_DATETIME,
    #[doc = "< @18 +2  Last recorded light sensor value in raw units, 0 = none"]
    pub light: ::std::os::raw::c_ushort,
    #[doc = "< @20 +2  Last recorded temperature sensor value in raw units, 0 = none"]
    pub temperature: ::std::os::raw::c_ushort,
    #[doc = "< @22 +1  Event flags since last packet, b0 = resume logging, b1 = single-tap event, b2 = double-tap event, b3-b7 = reserved for diagnostic use)"]
    pub events: ::std::os::raw::c_uchar,
    #[doc = "< @23 +1  Last recorded battery level in raw units, 0 = unknown"]
    pub battery: ::std::os::raw::c_uchar,
    #[doc = "< @24 +1  Sample rate code, (3200/(1<<(15-(rate & 0x0f)))) Hz"]
    pub sampleRate: ::std::os::raw::c_uchar,
    #[doc = "< @25 +1  0x32 (top nibble: number of axes = 3; bottom nibble: packing format - 2 = 3x 16-bit signed, 0 = 3x 10-bit signed + 2-bit exponent)"]
    pub numAxesBPS: ::std::os::raw::c_uchar,
    #[doc = "< @26 +2  Relative sample index from the start of the buffer where the whole-second timestamp is valid"]
    pub timestampOffset: ::std::os::raw::c_short,
    #[doc = "< @28 +2  Number of accelerometer samples (80 or 120)"]
    pub sampleCount: ::std::os::raw::c_ushort,
    #[doc = "< @30 +480 Raw sample data.  Each sample is either 3x 16-bit signed values (x, y, z) or one 32-bit packed value (The bits in bytes [3][2][1][0]: eezzzzzz zzzzyyyy yyyyyyxx xxxxxxxx, e = binary exponent, lsb on right)"]
    pub rawSampleData: [::std::os::raw::c_uchar; 480usize],
    #[doc = "< @510 +2 Checksum of packet (16-bit word-wise sum of the whole packet should be zero)"]
    pub checksum: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_OM_READER_DATA_PACKET() {
    const UNINIT: ::std::mem::MaybeUninit<OM_READER_DATA_PACKET> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OM_READER_DATA_PACKET>(),
        512usize,
        concat!("Size of: ", stringify!(OM_READER_DATA_PACKET))
    );
    assert_eq!(
        ::std::mem::align_of::<OM_READER_DATA_PACKET>(),
        1usize,
        concat!("Alignment of ", stringify!(OM_READER_DATA_PACKET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetHeader) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(packetHeader)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(packetLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceFractional) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(deviceFractional)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionId) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(sessionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequenceId) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(sequenceId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).light) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(light)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temperature) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).battery) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(battery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampleRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numAxesBPS) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(numAxesBPS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestampOffset) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(timestampOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampleCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(sampleCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rawSampleData) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(rawSampleData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        510usize,
        concat!(
            "Offset of field: ",
            stringify!(OM_READER_DATA_PACKET),
            "::",
            stringify!(checksum)
        )
    );
}
extern "C" {
    #[doc = " Accesses the contents of a raw data packet.\n This would not typically be used by an API client.\n The packet is loaded by calls to OmReaderNextBlock(), and remains valid until the next call of OmReaderNextBlock() or OmReaderClose() for the same reader handle.\n \\note If OmReaderNextBlock() returns 0, the reader has detected a checksum failure in the buffers contents, and any data values should be treated with caution.\n @param reader The handle to the reader.\n @return A pointer to the bytes in the raw data packet, or \\a NULL if none is available."]
    pub fn OmReaderRawDataPacket(reader: OmReaderHandle) -> *mut OM_READER_DATA_PACKET;
}
extern "C" {
    #[doc = " Closes the specified reader handle.\n Frees any resources allocated to the reader.\n @param reader The handle to the reader to close.\n @see OmReaderOpen()"]
    pub fn OmReaderClose(reader: OmReaderHandle);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
